% Extracting DBSCAN clusters
% Algorithm based off of the paper "OPTICS: Ordering Points To Identify
% the Clustering Structure"

% Inputs:
% RD: Reachability Distances generated by OPTICS
% minpts: Minimum number of points needed to be considered a cluster
% xi: Defines steep areas in reachability plot

% Outputs: 
% SetofClusters: structure array containing set of clusters

function [SetofClusters] = OpticsExtract(RD,minpts,xi)
% Initialize set of steep downward areas using structure array
% A structure array data type that groups related data using data 
% containers called fields 
% Each field can contain data of any type or size
SDASet = struct('start',[],'end',[],'mib',[]); 

% Initialize set of clusters using structure array
SetofClusters = struct('start',[],'end',[]);

% Initialize index
i = 1; 

% Initialize maximum in between value. By keeping track of these maximum
% inbetween values, we are able to save on computation resources
mib = 0;

% Structure index
l = 1;

% Cluster index
clustindex = 1;


while i < length(RD)
    % Setting global mib value
    mib = max(mib,RD(i));
    
    % Checks if i is start of steep downward area
    % Note: this is different than the definition in the paper
    % To be a steep downward point, the points successor must be xi% lower.
    % Thus, the point must be at least xi% larger
    if RD(i)*(1-xi) >= RD(i+1) 
        
        % Find the steep downward area, if any, from i
        j = i+1; % j is the index used to find the end of the steep downward area
        D = i;
        NotSDP=[]; % set of consecutive not steep downward points
        
        % We will keep track of one mib value for each steep down region in 
        % SDASet, containing the maximum value between the end of the steep
        % down region and the current index, and one global mib value 
        % containing the maximum between the end of the 
        % last steep (up or down) region found and the current index

        for k = 1:length(SDASet.mib)
            SDASet.mib(k) = max(RD(i:j-1));
        end
        
        % filtering set of steep down areas
        % we remove all steep down areas from SDASet whose start multiplied
        % by (1-xi) is smaller than the global mib value, thus reducing the 
        % number of potential clusters significantly
        while k <= length(SDASet.start)
            
            % if reachability plot height at the start of the downward area 
            % is xi% below the global mib value
            if RD(SDASet.start(k))*(1-xi) <= mib
                
                % Removing the cluster information from the list (hopefully)
                SDASet.start(k) = [];
                SDASet.end(k) = [];
                SDASet.mib(k) = [];
                
                % We have to go back a cluster index and exit loop
                l = length(SDASet.start)+1;
                if length(SDASet.start) > k
                    k = k+1;
                else 
                    k = k -1;
                end
            end
            k = k + 1;
        end
        
        % note that we do not need to check that the beginning of steep
        % downward area is a steep downward point because that is the
        % requirement to enter this part of the code.
        
        
        % We check that the end of D is a steep upward point, and we
        % ensure that each point in D is at least as high as its
        % predecssor in condition of the while loop
        while j < length(RD)-1 % Note that we can break out of this earlier
            
            % Check if next point is as low as the previous one
            if RD(j) <= RD(j-1)
                
                % If yes, add index to interval
                D = vertcat(D,j);
                
                % Check if end point is a steep downward point
                if RD(j)*(1-xi) >= RD(j+1)
                    
                    % If yes, continue to next index
                    j = j + 1;
                    continue
                else
                    % If no, add point to not steep downward point list
                    NotSDP = vertcat(NotSDP,j);
                    
                    % Ensures that NotSDP is a continuous list
                    if length(NotSDP) == 1 || j == NotSDP(length(NotSDP)-1) + 1
                        
                        % Check to see if the length of the continous list
                        % is less than minpts
                        if length(NotSDP) < minpts
                            j = j + 1;
                            continue
                        else
                            break
                        end
                    else
                        NotSDP = [];
                        j = j + 1;
                        continue
                    end
                end
            else
                break
            end
        end
        
        % We need to check if D ends with a steep downward point
        while length(D) > 1
            if RD(j-1)*(1-xi) >= RD(j)
                break
            else
                D(length(D)) = [];
                j = j - 1;
            end
        end
        
        % Store information in SDASet
        SDASet.start(l) = i;
        SDASet.end(l) = j-1;
        SDASet.mib(l) = 0;
        
        % increment structure array index
        l = l + 1;
        
        % set new index
        i = j;
        
        % set new global mib
        mib = RD(j);
        
    elseif RD(i) <= RD(i+1)*(1-xi) % of i is start of steep upward area
        % Compute steep upward area
        j = i+1;
        U = i;
        NotSUP = [];
        
        % Update mib values
        for k = 1:length(SDASet.mib)
            SDASet.mib(k) = max(RD(i:j-1));
        end
       
        % Filter SDA
        while k <= length(SDASet.start)
            if RD(SDASet.start(k))*(1-xi) <= mib
                SDASet.start(k) = [];
                SDASet.end(k) = [];
                SDASet.mib(k) = [];
                l = length(SDASet.start)+1;
                if length(SDASet.start) > k
                    k = k+1;
                else 
                    k = k -1;
                end
            end
            k = k + 1;
        end
        
        % Computing steep upward area
        while j < length(RD)-1 
            
            if RD(j-1) <= RD(j)
                U = vertcat(U,j);
                if RD(j) <= RD(j+1)*(1-xi)
                    j = j + 1;
                    continue
                else
                    NotSUP = vertcat(NotSUP,j);
                    if length(NotSUP) == 1 || j == NotSUP(length(NotSUP)-1) + 1
                        if length(NotSUP) <= minpts
                            j = j + 1;
                            continue
                        else
                            break
                        end
                    else
                        NotSUP = [];
                        j = j + 1;
                        continue
                    end
                end
            else
                break
            end
        end
        
        % We need to check if U ends with a steep upward point
        while length(U) > 1
            if RD(j-1) <= RD(j)*(1-xi)
                break
            else
                U(length(U)) = [];
                j = j - 1;
            end
        end
        
        i = j;
        
        mib = RD(j);
        
        % Checking cluster conditions
        for m = 1:length(SDASet.start)
            
            % We will check if the combination of D and U is valid
            if RD(j)*(1-xi) >= SDASet.mib(m)
                
                % Calculating cluster start and end points
                if RD(SDASet.start(m))*(1-xi) >= RD(j)
                    D = SDASet.start(m):SDASet.end(m);
                    RDD = find(RD(D)>=RD(j));
                    cluststart = D(max(RDD));
                    clustend = j-1;    
                elseif RD(j)*(1-xi) >= RD(SDASet.start(m))
                    U = min(U):max(U);
                    RDU = find(RD(U)<=RD(j));
                    cluststart = SDASet.start(m);
                    clustend = U(min(RDU));
                else
                    cluststart = SDASet.start(m);
                    clustend = j-1;
                end
                
                if clustend-cluststart >= minpts
                    SetofClusters.start(clustindex) = cluststart;
                    SetofClusters.end(clustindex) = clustend;
                    clustindex = clustindex + 1;
                end
            end
        end
        
     
    else
        i = i + 1;
    end    
end

end
   

